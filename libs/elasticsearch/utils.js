const _ = require('lodash');
const Bodybuilder = require('bodybuilder');

// MAy be deleted
const moment = require('moment');
const DATE_FORMAT = 'YYYY-MM-DD';
const REPO_RESULT_SIZE_MAX = 1000;
const REPO_RESULT_SIZE_DEFAULT = 10;
const TERM_RESULT_SIZE_MAX = 100;
const TERM_RESULT_SIZE_DEFAULT = 5;
const ELASTICSEARCH_SORT_ORDERS = ['asc', 'desc'];
const ELASTICSEARCH_SORT_MODES = ['min', 'max', 'sum', 'avg', 'median'];

/**
 * Flaten Elasticsearch mappings by type.
 * @param {object} mapping The Elasticsearch index mappings. https://www.elastic.co/guide/en/elasticsearch/reference/6.3/mapping.html
 * @returns {object} Flattened Elasticsearch mapping object grouped by type.
 */
function getFlattenedMappingPropertiesByType(mapping) {
  let props = {};

  const _recurseMappingTree = (mappingTree, pathArr) => {
    if (mappingTree["properties"]) {
      //We need to add any nested objects for groupings.
      if (mappingTree["type"] == "nested") {
        if (!props[mappingTree["type"]]) {
          props[mappingTree["type"]] = [];
        }
        props[mappingTree["type"]].push(pathArr.join("."));
      }
      _recurseMappingTree(mappingTree["properties"], pathArr);
    } else if (mappingTree["type"]) {
      if (!props[mappingTree["type"]]) {
        props[mappingTree["type"]] = [];
      }
      props[mappingTree["type"]].push(pathArr.join("."));
    } else {
      Object.keys(mappingTree).forEach((key) => {
        _recurseMappingTree(mappingTree[key], pathArr.concat(key));
      });
    }
  };

  _recurseMappingTree(mapping, []);
  return props;
}

/**
 * Delete private object keys ( prefixed with `_` ) from objects in passed collection.
 * @param {object} collection - list of objects to have keys deleted
 * @returns {object} An object with all fields prefixed by `_` deleted.
 */
function omitPrivateKeys (collection) {
  const omitFn = (value) => {
    if (value && typeof value === 'object') {
      Object.keys(value).forEach((key) => {
        if (key[0] === '_') {
          delete value[key];
        }
      });
    }
  };
  return _.cloneDeepWith(collection, omitFn);
}

/**
 * Parse the hits and source data from an Elasticsearch response object.
 * @param {object} response Elasticsearch reponse object.
 * @returns {object} Object with extracted data from _source and total items in result set.
 */
function parseResponse (response) {
  let hits = [];

  if (response.hasOwnProperty('hits') && response.hits.hasOwnProperty('hits')) {
    hits = response.hits.hits;
  }

  if (hits.length > 0) {
    return {
      total: response.hits.total,
      data: hits.map(hit => _.merge({ searchScore: hit._score }, omitPrivateKeys(hit._source)))
    };
  }

  return { total: 0, data: [] };
}

/**
 *
 * @param {object} param
 * @param {string} param.queryType The type of Elasticsearch query to make (Eg. match) - https://www.elastic.co/guide/en/elasticsearch/reference/6.3/full-text-queries.html
 * @param {string} param.field The index field you want to search against
 * @param {string} param.value The field value to search for.
 * @returns {object} Elasticsearch query object generated by BodyBuilder (https://www.npmjs.com/package/bodybuilder)
 */
function createFieldSearchQuery ({ queryType, field, value }) {
  let body = new Bodybuilder();

  body.query(queryType, field, value);
  let query = body.build('v2');

  return query;
}

function _addMatchPhraseForFullText ({ body, queryParams, field, boost }) {
  let query = { 'match_phrase': {} };
  query['match_phrase'][field] = {
    'query': queryParams.q
  };

  if (boost) {
    query['match_phrase'][field]['boost'] = boost;
  }

  body.query('bool', 'should', query);
}

function _addMatchForFullText ({ body, queryParams, field }) {
  let query = { 'match': {} };
  query['match'][field] = queryParams.q;

  body.query('bool', 'should', query);
}

function _addCommonCutoffForFullText ({ body, queryParams, field, boost }) {
  let query = { 'common': {} };

  query['common'][field] = {
    'query': queryParams.q,
    'cutoff_frequency': 0.001,
    'low_freq_operator': 'and'
  };

  if (boost) {
    query['common'][field]['boost'] = boost;
  }

  body.query('bool', 'should', query);
}

function _addFullTextQuery ({ body, searchQuery }) {
  const searchFields = [
    'name^5',
    'name.keyword^10',
    'description^2',
    'agency.acronym',
    'agency.name',
    'agency.name.keyword^5',
    'permissions.usageType',
    'tags^3',
    'tags.keyword^3',
    'languages',
    'languages.keyword^3'
  ];

  body.query('multi_match', 'fields', searchFields, { 'query': searchQuery }, { 'type': 'best_fields' });
}

function _addStringFilter ({ body, field, filter }) {
  if (filter instanceof Array) {
    filter.forEach((filterElement) => {
      body.orFilter('term', `${field}.keyword`, filterElement.toLowerCase());
    });
  } else {
    body.filter('term', `${field}.keyword`, filter.toLowerCase());
  }
}

function _addStringFilters ({ body, queryParams, searchProperties }) {
  searchProperties['keyword'].forEach((field) => {
    if (queryParams[field]) {
      _addStringFilter(body, field, queryParams[field]);
    }
  });
}

function _addDateRangeFilters ({ body, queryParams, searchProperties }) {
  const _addRangeFilter = (field, lteRange, gteRange) => {
    let ranges = {};

    const _addRangeForRangeType = (rangeType, dateRange) => {
      if (dateRange) {
        dateRange = moment(dateRange);
        if (dateRange.isValid()) {
          ranges[rangeType] = dateRange.utc().format(DATE_FORMAT);
        } else {
          throw new Error(
            `Invalid date supplied for ${field}_${rangeType}. ` +
            `Please use format ${DATE_FORMAT} or ISO8601.`
          );
        }
      }
    };

    _addRangeForRangeType('lte', lteRange);
    _addRangeForRangeType('gte', gteRange);

    body.filter('range', field, ranges);
  };

  let possibleRangeProps = searchProperties['date'];
  possibleRangeProps.forEach((field) => {
    let lteRange = queryParams[field + '_lte'];
    let gteRange = queryParams[field + '_gte'];
    if (lteRange || gteRange) {
      _addRangeFilter(field, lteRange, gteRange);
    }
  });
}

function _addSizeFromParams ({ body, queryParams }) {
  queryParams.size = queryParams.size || REPO_RESULT_SIZE_DEFAULT;
  let size = queryParams.size > REPO_RESULT_SIZE_MAX ? REPO_RESULT_SIZE_MAX : queryParams.size;
  let from = queryParams.from || 0;
  body.size(size);
  body.from(from);
}

function _addIncludeExclude ({ body, queryParams }) {
  let include = queryParams.include || null;
  let exclude = queryParams.exclude || null;
  let _source = {};
  const _enforceArray = (obj) => {
    if (!(obj instanceof Array)) {
      if (typeof (obj) === 'string') {
        return [obj];
      } else {
        return [];
      }
    } else {
      return obj;
    }
  };

  if (include) {
    _source.include = _enforceArray(include);
  }
  if (exclude) {
    _source.exclude = _enforceArray(exclude);
  }

  if (Object.keys(_source).length) {
    body.rawOption('_source', _source);
  }
}

/**
 * This adds all of our data field filters to a bodybuilder object
 *
 * @param {any} body An instance of a Bodybuilder class
 * @param {any} q The query parameters a user is searching for
 */
function _addFieldFilters ({ body, queryParams, searchProperties }) {
  _addStringFilters({ body, queryParams, searchProperties });
  _addDateRangeFilters({ body, queryParams, searchProperties });
}

function _getSortValues(querySortParams) {
  const sortValues = [];
  querySortParams.split(',').forEach(value => {
    if (value) {
      sortValues.push(value.split('__'));
    }
  });
  return sortValues;
}

function _getSortOptions(sortValue) {
  let sortOptions = {};

  sortValue.slice(1).forEach(item => {
    if (ELASTICSEARCH_SORT_ORDERS.includes(item)) {
      sortOptions.order = item;
    }
    if (ELASTICSEARCH_SORT_MODES.includes(item)) {
      sortOptions.mode = item;
    }
  });

  return sortOptions;
}

/**
 * Adds sorting depending on query input parameters.
 *
 * @param {any} body An instance of a Bodybuilder class
 * @param {any} queryParams The query parameters a user is searching for
 */
function _addSortOrder ({ body, queryParams }) {
  body.sort('_score', 'desc');
  body.sort('score', 'desc');

  if (queryParams['sort'] && (queryParams['sort'] !== 'asc' || queryParams['sort'] !== 'desc')) {
    const sortValues = _getSortValues(queryParams.sort);

    sortValues.forEach(sortValue => {
      const sortField = sortValue[0];

      body.sort(`${sortField}.keyword`,
        sortValue.length > 1
          ? _getSortOptions(sortValue)
          : 'asc');
    });
  }
}

/**
 *
 * @param {*} queryParams
 * @param {*} indexMappings
 */
function createReposSearchQuery ({ queryParams, indexMappings=null }) {
  let body = new Bodybuilder();
  let flattenedIndexMappings;

  if(indexMappings) {
    flattenedIndexMappings = getFlattenedMappingPropertiesByType(indexMappings);
  }

  if (queryParams.q) {
    _addFullTextQuery({ body, searchQuery: queryParams.q});
  }

  if(flattenedIndexMappings) {
    _addFieldFilters({ body, queryParams, searchProperties: flattenedIndexMappings });
  }

  _addSizeFromParams(body, queryParams);

  _addIncludeExclude(body, queryParams);
  _addSortOrder(body, queryParams);

  let query = body.build('v2');

  return query;
}

function getTermTypes({ queryParams, termTypesToSearch }) {
  let termTypes = termTypesToSearch;
  if (queryParams.term_type) {
    if (queryParams.term_type instanceof Array) {
      termTypes = queryParams.term_type;
    } else {
      termTypes = [queryParams.term_type];
    }
  }

  return termTypes;
}

// This gives me hives. It needs to be refactored
function searchTermsQuery ({ queryParams, termTypesToSearch }) {
  // TODO: use BodyBuilder more
  let body = new Bodybuilder();

  // add query terms (boost when phrase is matched)
  if (queryParams.term) {
    body.query('match', 'term_suggest', queryParams.term);
    body.query('match_phrase', 'term_suggest', { query: queryParams.term });
  }

  // set the term types (use defaults if not supplied)
  const termTypes = getTermTypes({ queryParams, termTypesToSearch });
  termTypes.forEach((termType) => {
    body.orFilter('term', 'term_type', termType);
  });

  // build the query and add custom fields (that bodyparser can't handle)
  let functionQuery = body.build('v2');

  // boost exact match
  if (queryParams.term) {
    functionQuery.query.bool.should = {
      'match': {
        'term': queryParams.term
      }
    };
  }

  // add scoring function - is this really necessary?
  functionQuery.functions = [{
    'field_value_factor': {
      'field': 'count_normalized',
      'factor': 0.25
    }
  }];
  functionQuery.boost_mode = 'multiply';

  let size = queryParams.size || TERM_RESULT_SIZE_DEFAULT;
  size = size > TERM_RESULT_SIZE_MAX ? TERM_RESULT_SIZE_MAX : size;
  let from = queryParams.from ? queryParams.from : 0;

  let query = {
    'query': { 'function_score': functionQuery },
    'size': size,
    'from': from
  };
  return query;
}

module.exports = {
  createFieldSearchQuery,
  createReposSearchQuery,
  omitPrivateKeys,
  parseResponse,
  searchTermsQuery,
  getFlattenedMappingPropertiesByType,
  _addFullTextQuery,
  _addStringFilter,
  _addStringFilters,
  _addDateRangeFilters,
  _addSizeFromParams,
  _addIncludeExclude,
  _addFieldFilters,
  _addSortOrder,
  _addMatchPhraseForFullText,
  _addMatchForFullText,
  _addCommonCutoffForFullText
};
